// Generates a typed API client from the Go route declarations. Supports
// TypeScript (--lang=ts, default) and Kotlin (--lang=kotlin) output.
package main

import (
	"errors"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/maruel/caic/backend/internal/server/dto"
)

var pathParamRe = regexp.MustCompile(`\{(\w+)\}`)

func main() {
	if err := run(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func run() error {
	lang := flag.String("lang", "ts", "output language: ts or kotlin")
	out := flag.String("out", "", "output directory (default: sdk/ relative to repo root for ts)")
	flag.Parse()

	switch *lang {
	case "ts", "":
		outDir := *out
		if outDir == "" {
			// Relative to go:generate CWD (backend/internal/server/dto/).
			outDir = "../../../../sdk"
		}
		return generateTS(outDir)
	case "kotlin":
		outDir := *out
		if outDir == "" {
			return errors.New("--out is required for --lang=kotlin")
		}
		return generateKotlin(outDir)
	default:
		return fmt.Errorf("unsupported language: %s", *lang)
	}
}

// generateTS generates the TypeScript API client (existing behavior).
func generateTS(outDir string) error {
	// Collect all referenced types for the import statement.
	types := map[string]struct{}{}
	for _, r := range dto.Routes {
		if r.ReqType != "" {
			types[r.ReqType] = struct{}{}
		}
		if r.RespType != "" {
			types[r.RespType] = struct{}{}
		}
	}
	types["ErrorResponse"] = struct{}{}

	sorted := sortedKeys(types)

	var b strings.Builder
	b.WriteString("// Code generated by gen-api-client. DO NOT EDIT.\n")
	fmt.Fprintf(&b, "import type { %s } from \"./types.gen\";\n\n", strings.Join(sorted, ", "))

	// APIError class.
	b.WriteString(`export class APIError extends Error {
  constructor(
    public status: number,
    public code: string,
    public details?: Record<string, unknown>,
  ) {
    super(code);
  }
}

`)

	// Generic request helper.
	b.WriteString(`async function request<T>(method: string, path: string, body?: unknown): Promise<T> {
  const init: RequestInit = { method, headers: { "Content-Type": "application/json" } };
  if (body !== undefined) init.body = JSON.stringify(body);
  const res = await fetch(path, init);
  if (!res.ok) {
    const err = (await res.json()) as ErrorResponse;
    throw new APIError(res.status, err.error.code, err.details);
  }
  return res.json() as Promise<T>;
}

`)

	// One function per route.
	for i := range dto.Routes {
		r := &dto.Routes[i]
		params := extractPathParams(r.Path)
		if r.IsSSE {
			writeTSSSEFunc(&b, r, params)
		} else {
			writeTSJSONFunc(&b, r, params)
		}
	}

	return os.WriteFile(filepath.Join(outDir, "api.gen.ts"), []byte(b.String()), 0o600)
}

func writeTSJSONFunc(b *strings.Builder, r *dto.Route, params []string) {
	respType := r.RespType
	if r.IsArray {
		respType += "[]"
	}

	// Build function signature.
	args := make([]string, 0, len(params)+1)
	for _, p := range params {
		args = append(args, p+": string")
	}
	if r.ReqType != "" {
		args = append(args, "req: "+r.ReqType)
	}

	tsPath := buildTSPath(r.Path, params)

	fmt.Fprintf(b, "export function %s(%s): Promise<%s> {\n", r.Name, strings.Join(args, ", "), respType)
	if r.ReqType != "" {
		fmt.Fprintf(b, "  return request<%s>(%q, %s, req);\n", respType, r.Method, tsPath)
	} else {
		fmt.Fprintf(b, "  return request<%s>(%q, %s);\n", respType, r.Method, tsPath)
	}
	b.WriteString("}\n\n")
}

func writeTSSSEFunc(b *strings.Builder, r *dto.Route, params []string) {
	args := make([]string, 0, len(params)+1)
	for _, p := range params {
		args = append(args, p+": string")
	}
	tsPath := buildTSPath(r.Path, params)
	if r.RespType != "" {
		args = append(args, "onMessage: (event: "+r.RespType+") => void")
		fmt.Fprintf(b, "export function %s(%s): EventSource {\n", r.Name, strings.Join(args, ", "))
		fmt.Fprintf(b, "  const es = new EventSource(%s);\n", tsPath)
		b.WriteString("  es.addEventListener(\"message\", (e) => {\n")
		fmt.Fprintf(b, "    onMessage(JSON.parse(e.data) as %s);\n", r.RespType)
		b.WriteString("  });\n")
		b.WriteString("  return es;\n")
	} else {
		fmt.Fprintf(b, "export function %s(%s): EventSource {\n", r.Name, strings.Join(args, ", "))
		fmt.Fprintf(b, "  return new EventSource(%s);\n", tsPath)
	}
	b.WriteString("}\n\n")
}

// generateKotlin generates Types.kt and ApiClient.kt in outDir.
func generateKotlin(outDir string) error {
	if err := os.MkdirAll(outDir, 0o750); err != nil {
		return err
	}
	if err := writeKotlinTypes(outDir); err != nil {
		return err
	}
	return writeKotlinClient(outDir)
}

func writeKotlinTypes(outDir string) error {
	const content = `// Code generated by gen-api-client. DO NOT EDIT.
package com.caic.sdk

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.JsonElement

typealias Harness = String

object Harnesses {
    const val Claude: Harness = "claude"
    const val Gemini: Harness = "gemini"
}

typealias EventKind = String

object EventKinds {
    const val Init: EventKind = "init"
    const val Text: EventKind = "text"
    const val ToolUse: EventKind = "toolUse"
    const val ToolResult: EventKind = "toolResult"
    const val Ask: EventKind = "ask"
    const val Usage: EventKind = "usage"
    const val Result: EventKind = "result"
    const val System: EventKind = "system"
    const val UserInput: EventKind = "userInput"
    const val Todo: EventKind = "todo"
}

object ErrorCodes {
    const val BadRequest = "BAD_REQUEST"
    const val NotFound = "NOT_FOUND"
    const val Conflict = "CONFLICT"
    const val InternalError = "INTERNAL_ERROR"
}

@Serializable
data class HarnessJSON(
    val name: String,
    val models: List<String>,
)

@Serializable
data class RepoJSON(
    val path: String,
    val baseBranch: String,
    @SerialName("repoURL") val repoURL: String? = null,
)

@Serializable
data class TaskJSON(
    val id: String,
    val task: String,
    val repo: String,
    @SerialName("repoURL") val repoURL: String? = null,
    val branch: String,
    val container: String,
    val state: String,
    val stateUpdatedAt: Double,
    val diffStat: List<DiffFileStat>? = null,
    @SerialName("costUSD") val costUSD: Double,
    val durationMs: Long,
    val numTurns: Int,
    val inputTokens: Int,
    val outputTokens: Int,
    val cacheCreationInputTokens: Int,
    val cacheReadInputTokens: Int,
    val error: String? = null,
    val result: String? = null,
    val harness: Harness,
    val model: String? = null,
    val agentVersion: String? = null,
    @SerialName("sessionID") val sessionID: String? = null,
    val containerUptimeMs: Long? = null,
    val inPlanMode: Boolean? = null,
)

@Serializable
data class StatusResp(val status: String)

@Serializable
data class CreateTaskResp(val status: String, val id: String)

@Serializable
data class CreateTaskReq(
    val prompt: String,
    val repo: String,
    val model: String? = null,
    val harness: Harness,
)

@Serializable
data class InputReq(val prompt: String)

@Serializable
data class RestartReq(val prompt: String)

@Serializable
data class DiffFileStat(
    val path: String,
    val added: Int,
    val deleted: Int,
    val binary: Boolean? = null,
)

@Serializable
data class SafetyIssue(
    val file: String,
    val kind: String,
    val detail: String,
)

@Serializable
data class SyncReq(val force: Boolean? = null)

@Serializable
data class SyncResp(
    val status: String,
    val diffStat: List<DiffFileStat>? = null,
    val safetyIssues: List<SafetyIssue>? = null,
)

@Serializable
data class UsageWindow(
    val utilization: Double,
    val resetsAt: String,
)

@Serializable
data class ExtraUsage(
    val isEnabled: Boolean,
    val monthlyLimit: Double,
    val usedCredits: Double,
    val utilization: Double,
)

@Serializable
data class UsageResp(
    val fiveHour: UsageWindow,
    val sevenDay: UsageWindow,
    val extraUsage: ExtraUsage,
)

@Serializable
data class VoiceTokenResp(
    val token: String,
    val expiresAt: String,
)

// Event types

@Serializable
data class EventMessage(
    val kind: EventKind,
    val ts: Long,
    val init: EventInit? = null,
    val text: EventText? = null,
    val toolUse: EventToolUse? = null,
    val toolResult: EventToolResult? = null,
    val ask: EventAsk? = null,
    val usage: EventUsage? = null,
    val result: EventResult? = null,
    val system: EventSystem? = null,
    val userInput: EventUserInput? = null,
    val todo: EventTodo? = null,
)

@Serializable
data class EventInit(
    val model: String,
    val agentVersion: String,
    @SerialName("sessionID") val sessionID: String,
    val tools: List<String>,
    val cwd: String,
)

@Serializable
data class EventText(val text: String)

@Serializable
data class EventToolUse(
    @SerialName("toolUseID") val toolUseID: String,
    val name: String,
    val input: JsonElement,
)

@Serializable
data class EventToolResult(
    @SerialName("toolUseID") val toolUseID: String,
    val durationMs: Long,
    val error: String? = null,
)

@Serializable
data class AskOption(
    val label: String,
    val description: String? = null,
)

@Serializable
data class AskQuestion(
    val question: String,
    val header: String? = null,
    val options: List<AskOption>,
    val multiSelect: Boolean? = null,
)

@Serializable
data class EventAsk(
    @SerialName("toolUseID") val toolUseID: String,
    val questions: List<AskQuestion>,
)

@Serializable
data class EventUsage(
    val inputTokens: Int,
    val outputTokens: Int,
    val cacheCreationInputTokens: Int,
    val cacheReadInputTokens: Int,
    val serviceTier: String? = null,
    val model: String,
)

@Serializable
data class EventResult(
    val subtype: String,
    val isError: Boolean,
    val result: String,
    val diffStat: List<DiffFileStat>? = null,
    @SerialName("totalCostUSD") val totalCostUSD: Double,
    val durationMs: Long,
    @SerialName("durationAPIMs") val durationAPIMs: Long,
    val numTurns: Int,
    val usage: EventUsage,
)

@Serializable
data class EventSystem(val subtype: String)

@Serializable
data class EventUserInput(val text: String)

@Serializable
data class TodoItem(
    val content: String,
    val status: String,
    val activeForm: String? = null,
)

@Serializable
data class EventTodo(
    @SerialName("toolUseID") val toolUseID: String,
    val todos: List<TodoItem>,
)

@Serializable
data class ErrorResponse(
    val error: ErrorDetails,
    val details: Map<String, JsonElement>? = null,
)

@Serializable
data class ErrorDetails(
    val code: String,
    val message: String,
)
`
	return os.WriteFile(filepath.Join(outDir, "Types.kt"), []byte(content), 0o600)
}

func writeKotlinClient(outDir string) error {
	var b strings.Builder

	// Static header and imports.
	b.WriteString(`// Code generated by gen-api-client. DO NOT EDIT.
package com.caic.sdk

import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import okhttp3.Response
import okhttp3.sse.EventSource
import okhttp3.sse.EventSourceListener
import okhttp3.sse.EventSources
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

class ApiException(
    val statusCode: Int,
    val code: String,
    message: String,
    val details: Map<String, kotlinx.serialization.json.JsonElement>? = null,
) : Exception(message)

class ApiClient(private val baseURL: String) {
    private val client = OkHttpClient()
    private val json = Json { ignoreUnknownKeys = true }
    private val jsonMediaType = "application/json".toMediaType()

    private suspend inline fun <reified T> request(method: String, path: String, body: Any? = null): T {
        val url = "$baseURL$path"
        val requestBody = if (body != null) {
            json.encodeToString(body).toRequestBody(jsonMediaType)
        } else {
            null
        }
        val request = Request.Builder()
            .url(url)
            .method(method, requestBody)
            .header("Content-Type", "application/json")
            .build()
        return suspendCancellableCoroutine { cont ->
            val call = client.newCall(request)
            cont.invokeOnCancellation { call.cancel() }
            call.enqueue(object : okhttp3.Callback {
                override fun onFailure(call: okhttp3.Call, e: java.io.IOException) {
                    cont.resumeWithException(e)
                }
                override fun onResponse(call: okhttp3.Call, response: Response) {
                    response.use { resp ->
                        val responseBody = resp.body?.string() ?: ""
                        if (!resp.isSuccessful) {
                            try {
                                val err = json.decodeFromString<ErrorResponse>(responseBody)
                                cont.resumeWithException(
                                    ApiException(resp.code, err.error.code, err.error.message, err.details)
                                )
                            } catch (_: Exception) {
                                cont.resumeWithException(
                                    ApiException(resp.code, "UNKNOWN", responseBody)
                                )
                            }
                            return
                        }
                        try {
                            cont.resume(json.decodeFromString<T>(responseBody))
                        } catch (e: Exception) {
                            cont.resumeWithException(e)
                        }
                    }
                }
            })
        }
    }

`)

	// Generate JSON endpoint methods from routes.
	b.WriteString("    // JSON endpoints\n")
	for i := range dto.Routes {
		r := &dto.Routes[i]
		if r.IsSSE {
			continue
		}
		params := extractPathParams(r.Path)
		writeKotlinJSONFunc(&b, r, params)
	}
	b.WriteString("\n")

	// Generate SSE endpoint methods from routes.
	b.WriteString("    // SSE endpoints\n")
	for i := range dto.Routes {
		r := &dto.Routes[i]
		if !r.IsSSE {
			continue
		}
		params := extractPathParams(r.Path)
		writeKotlinSSEFunc(&b, r, params)
	}
	// Static globalEvents (not in routes but part of the API surface).
	b.WriteString("    fun globalEvents(): Flow<EventMessage> = sseFlow(\"/api/v1/events\")\n")
	b.WriteString("\n")

	// sseFlow helper and reconnecting wrappers.
	b.WriteString(`    private fun sseFlow(path: String): Flow<EventMessage> = callbackFlow {
        val request = Request.Builder()
            .url("$baseURL$path")
            .header("Accept", "text/event-stream")
            .build()
        val factory = EventSources.createFactory(client)
        val source = factory.newEventSource(request, object : EventSourceListener() {
            override fun onEvent(eventSource: EventSource, id: String?, type: String?, data: String) {
                try {
                    val event = json.decodeFromString<EventMessage>(data)
                    trySend(event)
                } catch (_: Exception) {
                    // Skip malformed events.
                }
            }
            override fun onFailure(eventSource: EventSource, t: Throwable?, response: Response?) {
                close(t?.let { java.io.IOException("SSE connection failed", it) })
            }
            override fun onClosed(eventSource: EventSource) {
                close()
            }
        })
        awaitClose { source.cancel() }
    }

    // Reconnecting SSE wrappers with exponential backoff.
`)

	// Generate reconnecting wrappers for SSE routes.
	for i := range dto.Routes {
		r := &dto.Routes[i]
		if !r.IsSSE {
			continue
		}
		params := extractPathParams(r.Path)
		writeKotlinReconnectingFunc(&b, r, params)
	}
	// Static globalEventsReconnecting.
	b.WriteString("    fun globalEventsReconnecting(): Flow<EventMessage> = reconnectingFlow { globalEvents() }\n")
	b.WriteString("\n")

	b.WriteString(`    private fun reconnectingFlow(connect: () -> Flow<EventMessage>): Flow<EventMessage> = flow {
        var delayMs = 500L
        while (true) {
            try {
                connect().onEach { delayMs = 500L }.collect { emit(it) }
            } catch (e: CancellationException) {
                throw e
            } catch (_: Exception) {
                delay(delayMs)
                delayMs = (delayMs * 3 / 2).coerceAtMost(4000L)
            }
        }
    }
}
`)

	return os.WriteFile(filepath.Join(outDir, "ApiClient.kt"), []byte(b.String()), 0o600)
}

func writeKotlinJSONFunc(b *strings.Builder, r *dto.Route, params []string) {
	respType := r.RespType
	if r.IsArray {
		respType = "List<" + respType + ">"
	}

	// Build function parameters.
	args := make([]string, 0, len(params)+1)
	for _, p := range params {
		args = append(args, p+": String")
	}
	if r.ReqType != "" {
		args = append(args, "req: "+r.ReqType)
	}

	ktPath := buildKotlinPath(r.Path, params)

	sig := strings.Join(args, ", ")
	if r.ReqType != "" {
		fmt.Fprintf(b, "    suspend fun %s(%s): %s = request(%q, %s, req)\n", r.Name, sig, respType, r.Method, ktPath)
	} else {
		fmt.Fprintf(b, "    suspend fun %s(%s): %s = request(%q, %s)\n", r.Name, sig, respType, r.Method, ktPath)
	}
}

func writeKotlinSSEFunc(b *strings.Builder, r *dto.Route, params []string) {
	args := make([]string, 0, len(params))
	for _, p := range params {
		args = append(args, p+": String")
	}
	ktPath := buildKotlinPath(r.Path, params)
	fmt.Fprintf(b, "    fun %s(%s): Flow<EventMessage> = sseFlow(%s)\n", r.Name, strings.Join(args, ", "), ktPath)
}

func writeKotlinReconnectingFunc(b *strings.Builder, r *dto.Route, params []string) {
	// Build the function name: e.g. "taskEvents" -> "taskEventsReconnecting"
	reconnectName := r.Name + "Reconnecting"

	args := make([]string, 0, len(params))
	callArgs := make([]string, 0, len(params))
	for _, p := range params {
		args = append(args, p+": String")
		callArgs = append(callArgs, p)
	}

	fmt.Fprintf(b, "    fun %s(%s): Flow<EventMessage> = reconnectingFlow { %s(%s) }\n",
		reconnectName, strings.Join(args, ", "), r.Name, strings.Join(callArgs, ", "))
}

// buildKotlinPath returns a Kotlin string expression for the path. Uses string
// templates for paths with parameters.
func buildKotlinPath(path string, params []string) string {
	if len(params) == 0 {
		return fmt.Sprintf("%q", path)
	}
	kt := pathParamRe.ReplaceAllStringFunc(path, func(match string) string {
		name := match[1 : len(match)-1]
		return "$" + name
	})
	return fmt.Sprintf("%q", kt)
}

func extractPathParams(path string) []string {
	matches := pathParamRe.FindAllStringSubmatch(path, -1)
	out := make([]string, len(matches))
	for i, m := range matches {
		out[i] = m[1]
	}
	return out
}

// buildTSPath returns either a quoted string or a template literal for paths
// with parameters.
func buildTSPath(path string, params []string) string {
	if len(params) == 0 {
		return fmt.Sprintf("%q", path)
	}
	ts := pathParamRe.ReplaceAllStringFunc(path, func(match string) string {
		name := match[1 : len(match)-1]
		return "${" + name + "}"
	})
	return "`" + ts + "`"
}

func sortedKeys(m map[string]struct{}) []string {
	out := make([]string, 0, len(m))
	for k := range m {
		out = append(out, k)
	}
	// Simple insertion sort for a small set.
	for i := 1; i < len(out); i++ {
		for j := i; j > 0 && out[j] < out[j-1]; j-- {
			out[j], out[j-1] = out[j-1], out[j]
		}
	}
	return out
}
