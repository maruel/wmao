// Code generated by gen-api-client. DO NOT EDIT.
package com.caic.sdk

import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import okhttp3.Response
import okhttp3.sse.EventSource
import okhttp3.sse.EventSourceListener
import okhttp3.sse.EventSources
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

class ApiException(
    val statusCode: Int,
    val code: String,
    message: String,
    val details: Map<String, kotlinx.serialization.json.JsonElement>? = null,
) : Exception(message)

class ApiClient(baseURL: String) {
    private val baseURL: String = baseURL.trimEnd('/')
    private val client = OkHttpClient()
    private val json = Json { ignoreUnknownKeys = true }
    private val jsonMediaType = "application/json".toMediaType()

    private suspend inline fun <reified T> request(method: String, path: String, body: Any? = null): T {
        val url = "$baseURL$path"
        val requestBody = if (body != null) {
            json.encodeToString(body).toRequestBody(jsonMediaType)
        } else {
            null
        }
        val request = Request.Builder()
            .url(url)
            .method(method, requestBody)
            .header("Content-Type", "application/json")
            .build()
        return suspendCancellableCoroutine { cont ->
            val call = client.newCall(request)
            cont.invokeOnCancellation { call.cancel() }
            call.enqueue(object : okhttp3.Callback {
                override fun onFailure(call: okhttp3.Call, e: java.io.IOException) {
                    cont.resumeWithException(e)
                }
                override fun onResponse(call: okhttp3.Call, response: Response) {
                    response.use { resp ->
                        val responseBody = resp.body?.string() ?: ""
                        if (!resp.isSuccessful) {
                            try {
                                val err = json.decodeFromString<ErrorResponse>(responseBody)
                                cont.resumeWithException(
                                    ApiException(resp.code, err.error.code, err.error.message, err.details)
                                )
                            } catch (_: Exception) {
                                cont.resumeWithException(
                                    ApiException(resp.code, "UNKNOWN", responseBody)
                                )
                            }
                            return
                        }
                        try {
                            cont.resume(json.decodeFromString<T>(responseBody))
                        } catch (e: Exception) {
                            cont.resumeWithException(e)
                        }
                    }
                }
            })
        }
    }

    // JSON endpoints
    suspend fun listHarnesses(): List<HarnessJSON> = request("GET", "/api/v1/harnesses")
    suspend fun listRepos(): List<RepoJSON> = request("GET", "/api/v1/repos")
    suspend fun listTasks(): List<TaskJSON> = request("GET", "/api/v1/tasks")
    suspend fun createTask(req: CreateTaskReq): CreateTaskResp = request("POST", "/api/v1/tasks", req)
    suspend fun sendInput(id: String, req: InputReq): StatusResp = request("POST", "/api/v1/tasks/$id/input", req)
    suspend fun restartTask(id: String, req: RestartReq): StatusResp = request("POST", "/api/v1/tasks/$id/restart", req)
    suspend fun terminateTask(id: String): StatusResp = request("POST", "/api/v1/tasks/$id/terminate")
    suspend fun syncTask(id: String, req: SyncReq): SyncResp = request("POST", "/api/v1/tasks/$id/sync", req)
    suspend fun getUsage(): UsageResp = request("GET", "/api/v1/usage")
    suspend fun getVoiceToken(): VoiceTokenResp = request("GET", "/api/v1/voice/token")

    // SSE endpoints
    fun taskRawEvents(id: String): Flow<ClaudeEventMessage> = sseFlow<ClaudeEventMessage>("/api/v1/tasks/$id/raw_events")
    fun taskEvents(id: String): Flow<EventMessage> = sseFlow<EventMessage>("/api/v1/tasks/$id/events")
    fun globalEvents(): Flow<EventMessage> = sseFlow<EventMessage>("/api/v1/events")

    private inline fun <reified T> sseFlow(path: String): Flow<T> = callbackFlow {
        val request = Request.Builder()
            .url("$baseURL$path")
            .header("Accept", "text/event-stream")
            .build()
        val factory = EventSources.createFactory(client)
        val source = factory.newEventSource(request, object : EventSourceListener() {
            override fun onEvent(eventSource: EventSource, id: String?, type: String?, data: String) {
                try {
                    val event = json.decodeFromString<T>(data)
                    trySend(event)
                } catch (_: Exception) {
                    // Skip malformed events.
                }
            }
            override fun onFailure(eventSource: EventSource, t: Throwable?, response: Response?) {
                close(t?.let { java.io.IOException("SSE connection failed", it) })
            }
            override fun onClosed(eventSource: EventSource) {
                close()
            }
        })
        awaitClose { source.cancel() }
    }

    // Reconnecting SSE wrappers with exponential backoff.
    fun taskRawEventsReconnecting(id: String): Flow<ClaudeEventMessage> = reconnectingFlow { taskRawEvents(id) }
    fun taskEventsReconnecting(id: String): Flow<EventMessage> = reconnectingFlow { taskEvents(id) }
    fun globalEventsReconnecting(): Flow<EventMessage> = reconnectingFlow { globalEvents() }

    private fun <T> reconnectingFlow(connect: () -> Flow<T>): Flow<T> = flow {
        var delayMs = 500L
        while (true) {
            try {
                connect().onEach { delayMs = 500L }.collect { emit(it) }
            } catch (e: CancellationException) {
                throw e
            } catch (_: Exception) {
                delay(delayMs)
                delayMs = (delayMs * 3 / 2).coerceAtMost(4000L)
            }
        }
    }
}
